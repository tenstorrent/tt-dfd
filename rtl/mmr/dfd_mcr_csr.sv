// SPDX-FileCopyrightText: Copyright 2025 Tenstorrent AI ULC
// SPDX-License-Identifier: Apache-2.0

/*******************************************************************************
 * Registers
 *
 * This file was AUTO-GENERATED by this script:
 *       create_reg_rtl.py
 * ... from this input file:
 *       mcr_mmrs.py
 * ... using this as the top address space:
 *       mcr
 *
 * This file should not be modified by hand.
 *
 ******************************************************************************/

module dfd_mcr_csr
import dfd_mcr_csr_pkg::*;
`include "mcr_csr_pkg_list.svh"
#(
    parameter BASE_ADDR    = 0,                 // base address
    parameter ADDR_W       = 23,                // bit width of address
    parameter FLOP_IN_REQ  = 1,                 // add flop stage to bus inputs?
    parameter FLOP_RD_DATA = 1,                 // add flop stage to output rd data?
    parameter INSTR_TYPE_W = 2                  // write instr_type

) (

// Global Interface
input  logic                                    clk,
input  logic                                    reset_n,
input  logic                                    reset_n_warm_ovrride,

// Register Bus
input  logic                                    CsrCs,
input  logic                                    CsrWrEn,
input  logic                        [1:0]       CsrWrStrb,
input  logic                                    CsrRegSel,
input  logic                       [ADDR_W-1:0] CsrAddr,
input  logic                             [63:0] CsrWrData,
input  logic                 [INSTR_TYPE_W-1:0] CsrWrInstrType,
output logic                                    CsrWrReady,
output logic                                    CsrHit,
output McrCsrHit_s                              CsrHitList,
output logic                             [63:0] CsrRdData,

// Registers
output CrCdbgmuxselCsr_s                        CrCsrCdbgmuxsel,
output CrCdfdcsrCsr_s                           CrCsrCdfdcsr,

// HW Write Ports
// Write Broadcast Bus
output logic                                    CsrUpdateEn,
output logic                       [ADDR_W-1:0] CsrUpdateAddr,
output logic                             [63:0] CsrUpdateData

);


////////////////////////////////////////////////////////////////////////////////
// Internal Parameters
////////////////////////////////////////////////////////////////////////////////

// Addresses
localparam   [ADDR_W-1:0] ADDR_CSR_CDBGMUXSEL            = ADDR_W'(BASE_ADDR + 'h198);
localparam   [ADDR_W-1:0] ADDR_CSR_CDFDCSR               = ADDR_W'(BASE_ADDR + 'h1A0);



////////////////////////////////////////////////////////////////////////////////
// Signal Declarations
////////////////////////////////////////////////////////////////////////////////

logic                       reg_cs;
logic                       reg_wr_en;
logic           [1:0]       reg_wr_strb;
logic          [ADDR_W-1:0] reg_addr;
logic                       reg_wr_sel;
logic                       reg_rd_sel;
logic                [63:0] reg_wr_data;
logic    [INSTR_TYPE_W-1:0] reg_wr_instr_type;

logic                       reg_wr_ready;
McrCsrHit_s                 reg_prehit;
logic                       reg_hit;
logic                [63:0] reg_rd_data;

logic                       reg_write;
logic                       reg_read;

logic          [ADDR_W-1:0] reg_addr_d1;
logic                       reg_write_d1;
logic                [63:0] reg_rd_data_d1;

// Registers
logic                [63:0] CSR_CDbgMuxSel;
logic                [63:0] CSR_CDfdCsr;

// Fields
logic                 [5:0] CSR_CDbgMuxSel_F_Muxselseg7;
logic                 [5:0] CSR_CDbgMuxSel_F_Muxselseg6;
logic                 [5:0] CSR_CDbgMuxSel_F_Muxselseg5;
logic                 [5:0] CSR_CDbgMuxSel_F_Muxselseg4;
logic                 [5:0] CSR_CDbgMuxSel_F_Muxselseg3;
logic                 [5:0] CSR_CDbgMuxSel_F_Muxselseg2;
logic                 [5:0] CSR_CDbgMuxSel_F_Muxselseg1;
logic                 [5:0] CSR_CDbgMuxSel_F_Muxselseg0;
logic                 [7:0] CSR_CDbgMuxSel_F_Rsvd158;
logic                 [5:0] CSR_CDbgMuxSel_F_Dbmid;
logic                 [1:0] CSR_CDbgMuxSel_F_Dbmmode;
logic                 [0:0] CSR_CDfdCsr_F_DfdEn;
logic                [61:0] CSR_CDfdCsr_F_Rsvd621;
logic                 [0:0] CSR_CDfdCsr_F_DfdMmrLock;



////////////////////////////////////////////////////////////////////////////////
// Main Module Functionality
////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------
// Inputs
//------------------------------------------------------------------------------

if (FLOP_IN_REQ) begin : flop_in_req
    generic_dff #(.WIDTH(1)           , .RESET_VALUE(0)) reg_cs_ff             (.out(reg_cs)   , .in(CsrCs)    , .en(CsrCs|reg_cs), .clk(clk), .rst_n(reset_n));
    generic_dff #(.WIDTH(1)           , .RESET_VALUE(0)) reg_wr_en_ff          (.out(reg_wr_en), .in(CsrWrEn)  , .en(CsrCs), .clk(clk), .rst_n(reset_n));
    generic_dff #(.WIDTH(2)           , .RESET_VALUE(0)) reg_wr_strb_ff        (.out(reg_wr_strb), .in(CsrWrStrb)  , .en(CsrCs), .clk(clk), .rst_n(reset_n));
    generic_dff #(.WIDTH(ADDR_W)      , .RESET_VALUE(0)) reg_addr_ff           (.out(reg_addr) , .in(CsrAddr)  , .en(CsrCs), .clk(clk), .rst_n(reset_n));
    generic_dff #(.WIDTH(64)          , .RESET_VALUE(0)) reg_wr_data_ff        (.out(reg_wr_data), .in(CsrWrData), .en(CsrCs), .clk(clk), .rst_n(reset_n));
    generic_dff #(.WIDTH(1)           , .RESET_VALUE(0)) reg_rd_sel_ff         (.out(reg_rd_sel)  , .in(~CsrRegSel), .en(CsrCs), .clk(clk), .rst_n(reset_n));
    generic_dff #(.WIDTH(1)           , .RESET_VALUE(0)) reg_wr_sel_ff         (.out(reg_wr_sel)  , .in(CsrRegSel), .en(CsrCs), .clk(clk), .rst_n(reset_n));    
    generic_dff #(.WIDTH(INSTR_TYPE_W), .RESET_VALUE(0)) reg_wr_instr_type_ff  (.out(reg_wr_instr_type), .in(CsrWrInstrType), .en(CsrCs), .clk(clk), .rst_n(reset_n));
    generic_dff #(.WIDTH(1)           , .RESET_VALUE(0)) reg_wr_ready_ff       (.out(reg_wr_ready), .in(CsrCs & CsrWrEn), .en(CsrCs), .clk(clk), .rst_n(reset_n));
end else begin
    assign reg_cs             = CsrCs;
    assign reg_wr_en          = CsrWrEn;
    assign reg_wr_strb        = CsrWrStrb;
    assign reg_addr           = CsrAddr;
    assign reg_wr_data        = CsrWrData;
    assign reg_rd_sel         = ~CsrRegSel;
    assign reg_wr_sel         = CsrRegSel;
    assign reg_wr_instr_type  = CsrWrInstrType;
    assign reg_wr_ready       = CsrCs & CsrWrEn;
end

assign reg_write    = reg_cs &  reg_wr_en;
assign reg_read     = reg_cs;

generic_dff #(.WIDTH(ADDR_W), .RESET_VALUE(0)) reg_addr_d1_ff (.out(reg_addr_d1) , .in(reg_addr) , .en(reg_cs), .clk(clk), .rst_n(reset_n));
generic_dff #(.WIDTH(1)     , .RESET_VALUE(0)) reg_wren_d1_ff (.out(reg_write_d1), .in(reg_write), .en(reg_cs | reg_write_d1), .clk(clk), .rst_n(reset_n));


//------------------------------------------------------------------------------
// Register Writes and Counters
//------------------------------------------------------------------------------


//Register: CSR_CDBGMUXSEL
logic                                           CSR_CDbgMuxSel_F_Muxselseg7_WrEn;
logic [CR_CDBGMUXSEL_MUXSELSEG7_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg7_Data;
logic [CR_CDBGMUXSEL_MUXSELSEG7_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg7_DataEff;
assign CSR_CDbgMuxSel_F_Muxselseg7_DataEff = {reg_wr_data[63:58]};
assign CSR_CDbgMuxSel_F_Muxselseg7_Data = (CR_CDBGMUXSEL_MUXSELSEG7_WIDTH'(update_value(64'(CSR_CDbgMuxSel_F_Muxselseg7), 64'(CSR_CDbgMuxSel_F_Muxselseg7_DataEff[5:0]), reg_wr_instr_type)));
assign CSR_CDbgMuxSel_F_Muxselseg7_WrEn = (((reg_write & reg_wr_strb[1] & (reg_addr == ADDR_CSR_CDBGMUXSEL))));
generic_dff #(.WIDTH(CR_CDBGMUXSEL_MUXSELSEG7_WIDTH), .RESET_VALUE(0)) CSR_CDbgMuxSel_F_Muxselseg7_ff   (.out(CSR_CDbgMuxSel_F_Muxselseg7), .in(CSR_CDbgMuxSel_F_Muxselseg7_Data), .en(CSR_CDbgMuxSel_F_Muxselseg7_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

logic                                           CSR_CDbgMuxSel_F_Muxselseg6_WrEn;
logic [CR_CDBGMUXSEL_MUXSELSEG6_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg6_Data;
logic [CR_CDBGMUXSEL_MUXSELSEG6_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg6_DataEff;
assign CSR_CDbgMuxSel_F_Muxselseg6_DataEff = {reg_wr_data[57:52]};
assign CSR_CDbgMuxSel_F_Muxselseg6_Data = (CR_CDBGMUXSEL_MUXSELSEG6_WIDTH'(update_value(64'(CSR_CDbgMuxSel_F_Muxselseg6), 64'(CSR_CDbgMuxSel_F_Muxselseg6_DataEff[5:0]), reg_wr_instr_type)));
assign CSR_CDbgMuxSel_F_Muxselseg6_WrEn = (((reg_write & reg_wr_strb[1] & (reg_addr == ADDR_CSR_CDBGMUXSEL))));
generic_dff #(.WIDTH(CR_CDBGMUXSEL_MUXSELSEG6_WIDTH), .RESET_VALUE(0)) CSR_CDbgMuxSel_F_Muxselseg6_ff   (.out(CSR_CDbgMuxSel_F_Muxselseg6), .in(CSR_CDbgMuxSel_F_Muxselseg6_Data), .en(CSR_CDbgMuxSel_F_Muxselseg6_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

logic                                           CSR_CDbgMuxSel_F_Muxselseg5_WrEn;
logic [CR_CDBGMUXSEL_MUXSELSEG5_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg5_Data;
logic [CR_CDBGMUXSEL_MUXSELSEG5_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg5_DataEff;
assign CSR_CDbgMuxSel_F_Muxselseg5_DataEff = {reg_wr_data[51:46]};
assign CSR_CDbgMuxSel_F_Muxselseg5_Data = (CR_CDBGMUXSEL_MUXSELSEG5_WIDTH'(update_value(64'(CSR_CDbgMuxSel_F_Muxselseg5), 64'(CSR_CDbgMuxSel_F_Muxselseg5_DataEff[5:0]), reg_wr_instr_type)));
assign CSR_CDbgMuxSel_F_Muxselseg5_WrEn = (((reg_write & reg_wr_strb[1] & (reg_addr == ADDR_CSR_CDBGMUXSEL))));
generic_dff #(.WIDTH(CR_CDBGMUXSEL_MUXSELSEG5_WIDTH), .RESET_VALUE(0)) CSR_CDbgMuxSel_F_Muxselseg5_ff   (.out(CSR_CDbgMuxSel_F_Muxselseg5), .in(CSR_CDbgMuxSel_F_Muxselseg5_Data), .en(CSR_CDbgMuxSel_F_Muxselseg5_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

logic                                           CSR_CDbgMuxSel_F_Muxselseg4_WrEn;
logic [CR_CDBGMUXSEL_MUXSELSEG4_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg4_Data;
logic [CR_CDBGMUXSEL_MUXSELSEG4_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg4_DataEff;
assign CSR_CDbgMuxSel_F_Muxselseg4_DataEff = {reg_wr_data[45:40]};
assign CSR_CDbgMuxSel_F_Muxselseg4_Data = (CR_CDBGMUXSEL_MUXSELSEG4_WIDTH'(update_value(64'(CSR_CDbgMuxSel_F_Muxselseg4), 64'(CSR_CDbgMuxSel_F_Muxselseg4_DataEff[5:0]), reg_wr_instr_type)));
assign CSR_CDbgMuxSel_F_Muxselseg4_WrEn = (((reg_write & reg_wr_strb[1] & (reg_addr == ADDR_CSR_CDBGMUXSEL))));
generic_dff #(.WIDTH(CR_CDBGMUXSEL_MUXSELSEG4_WIDTH), .RESET_VALUE(0)) CSR_CDbgMuxSel_F_Muxselseg4_ff   (.out(CSR_CDbgMuxSel_F_Muxselseg4), .in(CSR_CDbgMuxSel_F_Muxselseg4_Data), .en(CSR_CDbgMuxSel_F_Muxselseg4_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

logic                                           CSR_CDbgMuxSel_F_Muxselseg3_WrEn;
logic [CR_CDBGMUXSEL_MUXSELSEG3_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg3_Data;
logic [CR_CDBGMUXSEL_MUXSELSEG3_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg3_DataEff;
assign CSR_CDbgMuxSel_F_Muxselseg3_DataEff = {reg_wr_data[39:34]};
assign CSR_CDbgMuxSel_F_Muxselseg3_Data = (CR_CDBGMUXSEL_MUXSELSEG3_WIDTH'(update_value(64'(CSR_CDbgMuxSel_F_Muxselseg3), 64'(CSR_CDbgMuxSel_F_Muxselseg3_DataEff[5:0]), reg_wr_instr_type)));
assign CSR_CDbgMuxSel_F_Muxselseg3_WrEn = (((reg_write & reg_wr_strb[1] & (reg_addr == ADDR_CSR_CDBGMUXSEL))));
generic_dff #(.WIDTH(CR_CDBGMUXSEL_MUXSELSEG3_WIDTH), .RESET_VALUE(0)) CSR_CDbgMuxSel_F_Muxselseg3_ff   (.out(CSR_CDbgMuxSel_F_Muxselseg3), .in(CSR_CDbgMuxSel_F_Muxselseg3_Data), .en(CSR_CDbgMuxSel_F_Muxselseg3_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

logic                                           CSR_CDbgMuxSel_F_Muxselseg2_WrEn;
logic [CR_CDBGMUXSEL_MUXSELSEG2_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg2_Data;
logic [CR_CDBGMUXSEL_MUXSELSEG2_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg2_DataEff;
assign CSR_CDbgMuxSel_F_Muxselseg2_DataEff = {reg_wr_strb[1] ? reg_wr_data[33:32] : CSR_CDbgMuxSel_F_Muxselseg2[5:4] , reg_wr_strb[0] ? reg_wr_data[31:28] : CSR_CDbgMuxSel_F_Muxselseg2[3:0]};
assign CSR_CDbgMuxSel_F_Muxselseg2_Data = (CR_CDBGMUXSEL_MUXSELSEG2_WIDTH'(update_value(64'(CSR_CDbgMuxSel_F_Muxselseg2), 64'(CSR_CDbgMuxSel_F_Muxselseg2_DataEff[5:0]), reg_wr_instr_type)));
assign CSR_CDbgMuxSel_F_Muxselseg2_WrEn = (((reg_write & (reg_addr == ADDR_CSR_CDBGMUXSEL))));
generic_dff #(.WIDTH(CR_CDBGMUXSEL_MUXSELSEG2_WIDTH), .RESET_VALUE(0)) CSR_CDbgMuxSel_F_Muxselseg2_ff   (.out(CSR_CDbgMuxSel_F_Muxselseg2), .in(CSR_CDbgMuxSel_F_Muxselseg2_Data), .en(CSR_CDbgMuxSel_F_Muxselseg2_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

logic                                           CSR_CDbgMuxSel_F_Muxselseg1_WrEn;
logic [CR_CDBGMUXSEL_MUXSELSEG1_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg1_Data;
logic [CR_CDBGMUXSEL_MUXSELSEG1_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg1_DataEff;
assign CSR_CDbgMuxSel_F_Muxselseg1_DataEff = {reg_wr_data[27:22]};
assign CSR_CDbgMuxSel_F_Muxselseg1_Data = (CR_CDBGMUXSEL_MUXSELSEG1_WIDTH'(update_value(64'(CSR_CDbgMuxSel_F_Muxselseg1), 64'(CSR_CDbgMuxSel_F_Muxselseg1_DataEff[5:0]), reg_wr_instr_type)));
assign CSR_CDbgMuxSel_F_Muxselseg1_WrEn = (((reg_write & reg_wr_strb[0] & (reg_addr == ADDR_CSR_CDBGMUXSEL))));
generic_dff #(.WIDTH(CR_CDBGMUXSEL_MUXSELSEG1_WIDTH), .RESET_VALUE(0)) CSR_CDbgMuxSel_F_Muxselseg1_ff   (.out(CSR_CDbgMuxSel_F_Muxselseg1), .in(CSR_CDbgMuxSel_F_Muxselseg1_Data), .en(CSR_CDbgMuxSel_F_Muxselseg1_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

logic                                           CSR_CDbgMuxSel_F_Muxselseg0_WrEn;
logic [CR_CDBGMUXSEL_MUXSELSEG0_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg0_Data;
logic [CR_CDBGMUXSEL_MUXSELSEG0_WIDTH     -1:0] CSR_CDbgMuxSel_F_Muxselseg0_DataEff;
assign CSR_CDbgMuxSel_F_Muxselseg0_DataEff = {reg_wr_data[21:16]};
assign CSR_CDbgMuxSel_F_Muxselseg0_Data = (CR_CDBGMUXSEL_MUXSELSEG0_WIDTH'(update_value(64'(CSR_CDbgMuxSel_F_Muxselseg0), 64'(CSR_CDbgMuxSel_F_Muxselseg0_DataEff[5:0]), reg_wr_instr_type)));
assign CSR_CDbgMuxSel_F_Muxselseg0_WrEn = (((reg_write & reg_wr_strb[0] & (reg_addr == ADDR_CSR_CDBGMUXSEL))));
generic_dff #(.WIDTH(CR_CDBGMUXSEL_MUXSELSEG0_WIDTH), .RESET_VALUE(0)) CSR_CDbgMuxSel_F_Muxselseg0_ff   (.out(CSR_CDbgMuxSel_F_Muxselseg0), .in(CSR_CDbgMuxSel_F_Muxselseg0_Data), .en(CSR_CDbgMuxSel_F_Muxselseg0_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

logic                                           CSR_CDbgMuxSel_F_Rsvd158_WrEn;
logic [CR_CDBGMUXSEL_RSVD158_WIDTH        -1:0] CSR_CDbgMuxSel_F_Rsvd158_Data;
logic [CR_CDBGMUXSEL_RSVD158_WIDTH        -1:0] CSR_CDbgMuxSel_F_Rsvd158_DataEff;
assign CSR_CDbgMuxSel_F_Rsvd158_DataEff = {reg_wr_data[15:8]};
assign CSR_CDbgMuxSel_F_Rsvd158_Data = (CR_CDBGMUXSEL_RSVD158_WIDTH'(update_value(64'(CSR_CDbgMuxSel_F_Rsvd158), 64'(CSR_CDbgMuxSel_F_Rsvd158_DataEff[7:0]), reg_wr_instr_type)));
assign CSR_CDbgMuxSel_F_Rsvd158_WrEn = (((reg_write & reg_wr_strb[0] & (reg_addr == ADDR_CSR_CDBGMUXSEL))));
generic_dff #(.WIDTH(CR_CDBGMUXSEL_RSVD158_WIDTH), .RESET_VALUE(0)) CSR_CDbgMuxSel_F_Rsvd158_ff   (.out(CSR_CDbgMuxSel_F_Rsvd158), .in(CSR_CDbgMuxSel_F_Rsvd158_Data), .en(CSR_CDbgMuxSel_F_Rsvd158_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

logic                                           CSR_CDbgMuxSel_F_Dbmid_WrEn;
logic [CR_CDBGMUXSEL_DBMID_WIDTH          -1:0] CSR_CDbgMuxSel_F_Dbmid_Data;
logic [CR_CDBGMUXSEL_DBMID_WIDTH          -1:0] CSR_CDbgMuxSel_F_Dbmid_DataEff;
assign CSR_CDbgMuxSel_F_Dbmid_DataEff = {reg_wr_data[7:2]};
assign CSR_CDbgMuxSel_F_Dbmid_Data = (CR_CDBGMUXSEL_DBMID_WIDTH'(update_value(64'(CSR_CDbgMuxSel_F_Dbmid), 64'(CSR_CDbgMuxSel_F_Dbmid_DataEff[5:0]), reg_wr_instr_type)));
assign CSR_CDbgMuxSel_F_Dbmid_WrEn = (((reg_write & reg_wr_strb[0] & (reg_addr == ADDR_CSR_CDBGMUXSEL))));
generic_dff #(.WIDTH(CR_CDBGMUXSEL_DBMID_WIDTH), .RESET_VALUE(0)) CSR_CDbgMuxSel_F_Dbmid_ff   (.out(CSR_CDbgMuxSel_F_Dbmid), .in(CSR_CDbgMuxSel_F_Dbmid_Data), .en(CSR_CDbgMuxSel_F_Dbmid_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

logic                                           CSR_CDbgMuxSel_F_Dbmmode_WrEn;
logic [CR_CDBGMUXSEL_DBMMODE_WIDTH        -1:0] CSR_CDbgMuxSel_F_Dbmmode_Data;
logic [CR_CDBGMUXSEL_DBMMODE_WIDTH        -1:0] CSR_CDbgMuxSel_F_Dbmmode_DataEff;
assign CSR_CDbgMuxSel_F_Dbmmode_DataEff = {reg_wr_data[1:0]};
assign CSR_CDbgMuxSel_F_Dbmmode_Data = (CR_CDBGMUXSEL_DBMMODE_WIDTH'(update_value(64'(CSR_CDbgMuxSel_F_Dbmmode), 64'(CSR_CDbgMuxSel_F_Dbmmode_DataEff[1:0]), reg_wr_instr_type)));
assign CSR_CDbgMuxSel_F_Dbmmode_WrEn = (((reg_write & reg_wr_strb[0] & (reg_addr == ADDR_CSR_CDBGMUXSEL))));
generic_dff #(.WIDTH(CR_CDBGMUXSEL_DBMMODE_WIDTH), .RESET_VALUE(0)) CSR_CDbgMuxSel_F_Dbmmode_ff   (.out(CSR_CDbgMuxSel_F_Dbmmode), .in(CSR_CDbgMuxSel_F_Dbmmode_Data), .en(CSR_CDbgMuxSel_F_Dbmmode_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

//Register: CSR_CDFDCSR
logic                                           CSR_CDfdCsr_F_DfdEn_WrEn;
logic [CR_CDFDCSR_DFDEN_WIDTH             -1:0] CSR_CDfdCsr_F_DfdEn_Data;
logic [CR_CDFDCSR_DFDEN_WIDTH             -1:0] CSR_CDfdCsr_F_DfdEn_DataEff;
assign CSR_CDfdCsr_F_DfdEn_DataEff = {reg_wr_data[63:63]};
assign CSR_CDfdCsr_F_DfdEn_Data = (CR_CDFDCSR_DFDEN_WIDTH'(update_value(64'(CSR_CDfdCsr_F_DfdEn), 64'(CSR_CDfdCsr_F_DfdEn_DataEff[0:0]), reg_wr_instr_type)));
assign CSR_CDfdCsr_F_DfdEn_WrEn = (((reg_write & reg_wr_strb[1] & (reg_addr == ADDR_CSR_CDFDCSR))));
generic_dff #(.WIDTH(CR_CDFDCSR_DFDEN_WIDTH), .RESET_VALUE(0)) CSR_CDfdCsr_F_DfdEn_ff   (.out(CSR_CDfdCsr_F_DfdEn), .in(CSR_CDfdCsr_F_DfdEn_Data), .en(CSR_CDfdCsr_F_DfdEn_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

assign CSR_CDfdCsr_F_Rsvd621 = 62'h0;

logic                                           CSR_CDfdCsr_F_DfdMmrLock_WrEn;
logic [CR_CDFDCSR_DFDMMRLOCK_WIDTH        -1:0] CSR_CDfdCsr_F_DfdMmrLock_Data;
logic [CR_CDFDCSR_DFDMMRLOCK_WIDTH        -1:0] CSR_CDfdCsr_F_DfdMmrLock_DataEff;
assign CSR_CDfdCsr_F_DfdMmrLock_DataEff = {reg_wr_data[0:0]};
assign CSR_CDfdCsr_F_DfdMmrLock_Data = (CR_CDFDCSR_DFDMMRLOCK_WIDTH'(update_value(64'(CSR_CDfdCsr_F_DfdMmrLock), 64'(CSR_CDfdCsr_F_DfdMmrLock_DataEff[0:0]), reg_wr_instr_type)));
assign CSR_CDfdCsr_F_DfdMmrLock_WrEn = (((reg_write & reg_wr_strb[0] & (reg_addr == ADDR_CSR_CDFDCSR))));
generic_dff #(.WIDTH(CR_CDFDCSR_DFDMMRLOCK_WIDTH), .RESET_VALUE(1)) CSR_CDfdCsr_F_DfdMmrLock_ff   (.out(CSR_CDfdCsr_F_DfdMmrLock), .in(CSR_CDfdCsr_F_DfdMmrLock_Data), .en(CSR_CDfdCsr_F_DfdMmrLock_WrEn), .clk(clk), .rst_n(reset_n_warm_ovrride));

//------------------------------------------------------------------------------
// Register Reads
//------------------------------------------------------------------------------

// Construct register vectors
assign CSR_CDbgMuxSel = {
    CSR_CDbgMuxSel_F_Muxselseg7,
    CSR_CDbgMuxSel_F_Muxselseg6,
    CSR_CDbgMuxSel_F_Muxselseg5,
    CSR_CDbgMuxSel_F_Muxselseg4,
    CSR_CDbgMuxSel_F_Muxselseg3,
    CSR_CDbgMuxSel_F_Muxselseg2,
    CSR_CDbgMuxSel_F_Muxselseg1,
    CSR_CDbgMuxSel_F_Muxselseg0,
    CSR_CDbgMuxSel_F_Rsvd158,
    CSR_CDbgMuxSel_F_Dbmid,
    CSR_CDbgMuxSel_F_Dbmmode
};
assign CSR_CDfdCsr = {
    CSR_CDfdCsr_F_DfdEn,
    CSR_CDfdCsr_F_Rsvd621,
    CSR_CDfdCsr_F_DfdMmrLock
};

// Register reads
always_comb begin
    reg_prehit  = '0;
    reg_rd_data = '0;
    unique case (reg_addr)
        ADDR_CSR_CDBGMUXSEL                     : begin reg_prehit.CrCsrCdbgmuxselHit = 1'b1; reg_rd_data = {CSR_CDbgMuxSel}; end
        ADDR_CSR_CDFDCSR                        : begin reg_prehit.CrCsrCdfdcsrHit = 1'b1; reg_rd_data = {CSR_CDfdCsr}; end
        default:  begin
            reg_prehit  = '0;
            reg_rd_data = '0;
        end
    endcase
end

assign reg_hit = reg_read & |reg_prehit;

// Write broadcast
always_comb begin
    unique case (reg_addr_d1)
        ADDR_CSR_CDBGMUXSEL                     : begin reg_rd_data_d1 = {CSR_CDbgMuxSel}; end
        ADDR_CSR_CDFDCSR                        : begin reg_rd_data_d1 = {CSR_CDfdCsr}; end
        default:  begin
            reg_rd_data_d1 = '0;
        end
    endcase
end

//------------------------------------------------------------------------------
// Outputs
//------------------------------------------------------------------------------

assign CsrWrReady = reg_wr_ready;

if (FLOP_RD_DATA) begin : flop_rd_data
    generic_dff #(.WIDTH(1) , .RESET_VALUE(0)) Csr_Hit_ff    (.out(CsrHit)   , .in(reg_hit)    , .en(reg_cs | CsrHit), .clk(clk), .rst_n(reset_n));
    generic_dff #(.WIDTH(CR_NUM_REGISTERS) , .RESET_VALUE(0)) Csr_Hit_List_ff    (.out(CsrHitList)   , .in(reg_prehit)    , .en(reg_cs | CsrHit), .clk(clk), .rst_n(reset_n));
    generic_dff #(.WIDTH(64), .RESET_VALUE(0)) Csr_RdData_ff (.out(CsrRdData), .in(reg_rd_data), .en(reg_cs), .clk(clk), .rst_n(reset_n));
end else begin
    assign CsrHit     = reg_hit;
    assign CsrHitList = reg_prehit;
    assign CsrRdData  = reg_rd_data;
end

assign CsrUpdateEn                              = reg_write_d1;
assign CsrUpdateAddr                            = reg_addr_d1;
assign CsrUpdateData                            = reg_rd_data_d1;

assign CrCsrCdbgmuxsel.Muxselseg7               = CSR_CDbgMuxSel_F_Muxselseg7;
assign CrCsrCdbgmuxsel.Muxselseg6               = CSR_CDbgMuxSel_F_Muxselseg6;
assign CrCsrCdbgmuxsel.Muxselseg5               = CSR_CDbgMuxSel_F_Muxselseg5;
assign CrCsrCdbgmuxsel.Muxselseg4               = CSR_CDbgMuxSel_F_Muxselseg4;
assign CrCsrCdbgmuxsel.Muxselseg3               = CSR_CDbgMuxSel_F_Muxselseg3;
assign CrCsrCdbgmuxsel.Muxselseg2               = CSR_CDbgMuxSel_F_Muxselseg2;
assign CrCsrCdbgmuxsel.Muxselseg1               = CSR_CDbgMuxSel_F_Muxselseg1;
assign CrCsrCdbgmuxsel.Muxselseg0               = CSR_CDbgMuxSel_F_Muxselseg0;
assign CrCsrCdbgmuxsel.Rsvd158                  = CSR_CDbgMuxSel_F_Rsvd158;
assign CrCsrCdbgmuxsel.Dbmid                    = CSR_CDbgMuxSel_F_Dbmid;
assign CrCsrCdbgmuxsel.Dbmmode                  = CSR_CDbgMuxSel_F_Dbmmode;
assign CrCsrCdfdcsr.DfdEn                       = CSR_CDfdCsr_F_DfdEn;
assign CrCsrCdfdcsr.Rsvd621                     = CSR_CDfdCsr_F_Rsvd621;
assign CrCsrCdfdcsr.DfdMmrLock                  = CSR_CDfdCsr_F_DfdMmrLock;

//------------------------------------------------------------------------------
// update_value
// update register value based on input instr_type.
// instr_type: 2'b01 : op1 data is mask to set bits
// instr_type: 2'b10 : op1 data is mask to clear bits
// instr_type: othes : op1 data is written to register
//------------------------------------------------------------------------------
function automatic [63:0] update_value;
input [63:0] old_value;
input [63:0] op1;
input  [1:0] instr_type;
  begin
    if (instr_type == 2'b01)
       update_value = old_value | op1;
    else if (instr_type == 2'b10)
       update_value = old_value & ~op1;
    else
       update_value = op1;
  end
endfunction


endmodule
// Local Variables:
// verilog-library-directories:(".")
// verilog-library-extensions:(".sv" ".h" ".v")
// verilog-typedef-regexp: "_[eus]$"
// End:



