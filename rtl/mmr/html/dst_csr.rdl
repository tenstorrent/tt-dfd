addrmap dst {
    reg {
        desc = "";
        regwidth = 0x20;
//         constraint_p = "";
        field {
            sw = rw;
            hw = r;
        } Trdstactive[0:0] = 0x0;
        field {
            sw = rw;
            hw = r;
        } Trdstenable[1:1] = 0x0;
        field {
            sw = rw;
            hw = w;
        } Trdstinsttracing[2:2] = 0x0;
        field {
            sw = r;
            hw = w;
        } Trdstempty[3:3] = 0x1;
        field {
            sw = r;
            hw = r;
        } Trdstinstmode[6:4] = 0x6;
        field {
            sw = r;
            hw = r;
        } Trdstcontext[9:9] = 0x0;
        field {
            sw = rw;
            hw = r;
        } Trdstinsttriggerenable[11:11] = 0x0;
        field {
            sw = r;
            hw = r;
        } Trdstinststalloroverflow[12:12] = 0x0;
        field {
            sw = r;
            hw = r;
        } Trdstinststallena[13:13] = 0x0;
        field {
            sw = r;
            hw = r;
        } Trdstinhibitsrc[15:15] = 0x0;
        field {
            desc = "When the field is set tp 2'b10, sent timestamp. All other vlaues not NA.";
            sw = rw;
            hw = r;
        } Trdstsyncmode[17:16] = 0x0;
        field {
            desc = "When trDstSyncMode is set to 2'b10, timestamp will be sent for every 2^(trDstSyncMax + 4) Cluster clocks.";
            sw = rw;
            hw = r;
        } Trdstsyncmax[23:20] = 0x0;
        field {
            desc = "bit[0]: XOR Enable, bit[1]: VLT Enable. Supported values : 2'b3 (XOR+VLT Compression), 2'b1 (XOR Compresion), 2'b0 (No Compression)";
            sw = rw;
            hw = r;
        } Trdstformat[26:24] = 0x3;
    } Trdstcontrol @ 0x10000;
    reg {
        desc = "";
        regwidth = 0x20;
//         constraint_p = "";
        field {
            sw = r;
            hw = r;
        } Trdstvermajor[3:0] = 0x1;
        field {
            sw = r;
            hw = r;
        } Trdstverminor[7:4] = 0x0;
        field {
            sw = r;
            hw = r;
        } Trdstcomptype[11:8] = 0x1;
        field {
            sw = r;
            hw = r;
        } Trdstprotocolmajor[19:16] = 0x1;
        field {
            sw = r;
            hw = r;
        } Trdstprotocolminor[23:20] = 0x0;
        field {
            desc = "Specify frame length. Frame Length = trDstVendorFrameLength* 64 ; Frame Length should be a multiple of Bank Data Width.";
            sw = rw;
            hw = r;
        } Trdstvendorframelength[27:24] = 0x1;
        field {
            desc = "Specify Stream length. A stream starts with \"no compressed packet\". Stream length specifies number of frames before a non-compressed packet is sent.Stream Length = 32* 2^(trDstVendorStreamLength + 1)";
            sw = rw;
            hw = r;
        } Trdstvendorstreamlength[30:28] = 0x4;
    } Trdstimpl @ 0x10040;
    reg {
        desc = "";
        regwidth = 0x20;
//         constraint_p = "";
        field {
            sw = r;
            hw = r;
        } Trdstinstnoaddrdiff[0:0] = 0x0;
        field {
            sw = r;
            hw = r;
        } Trdstinstnotrapaddr[1:1] = 0x0;
        field {
            sw = r;
            hw = r;
        } Trdstinstenrepeatedhistory[8:8] = 0x0;
        field {
            sw = rw;
            hw = r;
        } Trdstsrcid[27:16] = 0x0;
        field {
            sw = rw;
            hw = r;
        } Trdstsrcbits[31:28] = 0x4;
    } Trdstinstfeatures @ 0x10080;
    reg {
        desc = "";
        regwidth = 0x20;
//         constraint_p = "";
        field {
            desc = "Trace Source ID (FIXME: Base Address, Tool Issue)";
            sw = rw;
            hw = r;
        } TraceSourceId[3:0] = 0x0;
        field {
            desc = "Use \"Filler Packet\" to align a stream of trace packets within a frame boundary.";
            sw = rw;
            hw = r;
        } TraceFrameFillByte[11:4] = 0x81;
        field {
            desc = "Use trDstImpl[trDstVendorFrameLength] for Frame Length programming. Register field ZBB-ed.";
            sw = rw;
            hw = r;
        } FrameLenghtInBytes[15:12] = 0x2;
        field {
            desc = "Enable Frame Mode (Frame Mode: Always pack \"frame length\" number of bytes for trace transmission). If flush to memory is stalled (due to silicon bug), we can have incomplete packets in memory. Frame Mode will help SW decoder to avoid reading incomplete trasnmitted packets. In Frame Mode, SW will get a memory pointer that is aligned to Frame Length. HW will ensure  there are no incomplete packets incluced in the region pointed by memory pointer.";
            sw = rw;
            hw = r;
        } FrameModeEnable[20:20] = 0x1;
        field {
            desc = "Closure Mode: 1: Close frame with a packet no larger than max packet size  before any overflow (due to packets crossing frame boundary). 0: Close frame when packets cross boundary. Push back packet crossing frame boundary to packet generator.";
            sw = rw;
            hw = r;
        } FrameClosureMode[21:21] = 0x1;
    } CDbgDebugTraceCfg @ 0x11A00;
};

/*
        THIS IS AN AUTOGENERATED ADDRESS MAP

        Trdstcontrol             @ 0x1000
        Trdstimpl                @ 0x1004
        Trdstinstfeatures        @ 0x1008
        CDbgDebugTraceCfg        @ 0x11A0
*/

